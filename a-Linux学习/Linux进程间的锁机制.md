[https://blog.csdn.net/yankai0219/article/details/8453317]

[http://simohayha.iteye.com/blog/658012]

nginx中使用的锁是自己来实现的，这里锁的实现分为两种情况，一种是支持原子操作的情况，也就是由NGX_HAVE_ATOMIC_OPS这个宏来进行控制的，一种是不支持原子操作，这是是使用文件锁来实现。


### 进程间锁的实现
[linux多线程锁机制](https://blog.csdn.net/redsuntim/article/details/8718487)


1. 访问共享资源的代码区域称为临界区。自旋锁(spinlock)和互斥体(mutex)是保护内核临界区的两种基本机制。

2.互斥锁：pthread_mutex，属于sleep-waiting类型的锁。互斥量是实现最简单的锁类型，因此有一些教科书一般以互斥量为例对锁原语进行描述。互斥量的释放并不仅仅依赖于释放操作，还可以引入一个定时器属性。如果在释放操作执行前发生定时器超时，则互斥量也会释放代码块或共享存储区供其他线程访问。当有异常发生时，可使用try-finally语句来确保互斥量被释放。定时器状态或try-finally语句的使用可以避免产生死锁。

3.自旋锁：pin lock，属于busy-wait类型的锁。 旋转锁是一种非阻塞锁，由某个线程独占。采用旋转锁时，等待线程并不静态地阻塞在同步点，而是必须“旋转”，不断尝试直到最终获得该锁。旋转锁多用于多处理器系统中。这是因为，如果在单核处理器中采用旋转锁，当一个线程正在“旋转”时，将没有执行资源可供另一释放锁的线程使用。旋转锁适合于任何锁持有时间少于将一个线程阻塞和唤醒所需时间的场合。线程控制的变更，包括线程上下文的切换和线程数据结构的更新，可能比旋转锁需要更多的指令周期。旋转锁的持有时间应该限制在线程上下文切换时间的50%到100%之间（Kleiman，1996年）。在线程调用其他子系统时，线程不应持有旋转锁。对旋转锁的不当使用可能会导致线程饿死，因此需谨慎使用这种锁机制。旋转锁导致的饿死问题可使用排队技术来解决，即每个等待线程按照先进先出的顺序或者队列结构在一个独立的局部标识上进行旋转。自旋锁有在内核可抢占式或SMP的情况下才真正需要。




### Linux 内存映射 MMAP
