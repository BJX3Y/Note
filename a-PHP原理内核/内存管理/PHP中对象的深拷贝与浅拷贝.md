自PHP5起，new运算符自动返回一个引用，一个 对象变量 已经不再保存整个对象的值，只是保存一个标识符来访问真正的对象内容。当对象作为参数传递，作为结果返回，或者赋值给另外一个变量，另外一个变量跟原来的不是引用的关系，只是他们都保存着同一个标识符的拷贝，这个标识符指向同一个对象的真正内容。
这里举个栗子：

```
class Example1
{
  public $name;

  public function __construct($name)
  {
      $this->name = $name;
  }
}

$ex1 = new Example('test1');// $ex1->name现在是：test1
$ex2 = $ex1;// $ex2->name现在是：test1

$ex2->name = 'test2';// 这样修改一下之后，$ex1->name与$ex2->name都变为了：test2
```

通过上面这个例子，应该可以理解对象间引用的概念了，那么我们继续往下走，在php中提供了 clone 这个关键字来进行对象复制，还是用上面的类来演示一下：

```
$ex1 = new Example('test1');// $ex1->name现在是：test1
$ex2 = clone $ex1;//$ex2->name现在是：test1

$ex2->name = 'test2';//现在$ex1->name还是test1,而$ex2->name是test2
```


这里看到，通过clone之后，`$ex1与$ex2`是两个不同的对象，他们拥有各自的变量环境。但是这里需要注意，在这两个对象内部，拥有的是值类型的数据，如果是内部拥有的是引用类型，那么通过clone得到的新对象中的引用则仍然指向原引用。这里就引申出 浅复制 与 深复制 的概念：
浅复制： 使用clone来复制对象，这种复制叫做“浅复制“，被赋值对象的所有变量都还有与原来对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。
深复制：被复制的对象的所有的变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。

默认使用 clone 是进行一个浅复制，那么如何才能进行深复制呢？
方式一：利用__clone方法

```
public function __clone()
{
  $this->obj = new Obj();
}
```

这种方式非常直观，但是却有一个很麻烦的操作方式，就是当类中包含多个引用时，你就需要在__clone方法中逐个重新设置。而且还要处理一些循环引用的问题。是很复杂的。

方式二：利用串行化(冷藏与解冻)

```
$tmp = serialize($ex1);
$ex2 = unserialize($tmp);
```
这时候得到的$ex2就是一个全新的对象，这个过程在java中也叫作”冷藏“与”解冻“过程。
序列化是一个递归的过程，我们不需要理会被对象内部引用了多少个对象以及引用了多少层对象，我们都可以彻底的复制。方式二真的很黄很暴力，但是我很喜欢。
