PHP变量在内存中的表示:zval

>**PHP中的参数传递到底是传值的，还是传引用的？**
这是一个基础问题，还有些历史包袱。我们都知道PHP刚被创造的时候并不支持面向对象的特性，所以如果你是一个比较资深的php程序员的话，你肯定听说过PHP是传值的，不过如果你是从Java或者C#转到PHP，而且最开始用的php 5.2(>=)的话，你很可能会认为PHP是传引用的。

### zval（zend value）

PHP的解释器被称为`zend engine`，所以顾名思义zend value就是zend engine中的value.

PHP中的变量在内存中是以`zval结构体`的形式存在的，zval包含了变量的值以及其他一些相关的信息.

```
typedef struct _zval_struct zval;
...
struct _zval_struct {
    /* Variable information */
    zvalue_value value;     /* value */
    zend_uint refcount__gc;
    zend_uchar type;    /* active type */
    zend_uchar is_ref__gc;
};
```


```
// 共用体union:使用相同的内存地址

typedef union _zvalue_value {
    long lval;
    double dval;
    struct {
        char *val;
        int len;
    } str;
    HashTable *ht;
    zend_object_value obj;
} zvalue_value;
```

>[**可以不读**] union是C语言中的东西，现在谈到的这些东西都是跟C语言相关。因为PHP就是用C语言开发的，所以我们谈论底层的东西时，就必然会谈到C语言的一些东西。不过还好，对于这篇文章而言我们用到的C语言的东西很少（C语言中的概念本来就不多）。这里出现的union跟struct（联合体）类似，从定义来看，都是一组字段的组合，不过union一次只能表示（使用）一个字段，所以如果你定义了一个zvalue_value类型的变量value，如果将其中的lval设置为1，那么你只能使用value.lval。如果你使用其他的字段，例如value.dval，会得到意想不到的结果。这是因为union在内存中的大小是一定的，跟其中最大字段的大小一致（不管你使用哪个字段），当你访问其中某个字段的时候，它实际上只是从内存中读取一块数据，这个内存块的大小就是这个字段的大小，而起始地址就是对应的union的起始地址，然后再把从内存读到的这个数据转换为字段类型所对应的数据值。

从上面的union中我们可以看到，它可以表示PHP中的`整型、浮点型、字符串、数组（hashtable）和对象`等类型;
考虑到`resource类型`在PHP中只是一个整型值，所以它也会被保存到lval中，它的处理会比较特殊。
在PHP中`bool类型`的值一般用0（表示false）和1（表示true）两个整型数字表示，所以它的值也会保存在lval中的。
还有没有提到的类型是`NULL类型`，因为NULL值没有任何意义，所以不需要任何字段表示，直接使用c语言中的null表示它的值。


以上是变量的值的联合体zvalue_value，下面我们再来看看zval。zval是一个struct（结构体），它包含了一个PHP变量在内存中表示所需的所有东西：

```
typedef struct _zval_struct {
    zvalue_value value;
    zend_uint refcount__gc;
    zend_uchar type;
    zend_uchar is_ref__gc;
} zval;
```

+ value是上面用于表示值的联合体，

+ type则是变量的类型，php有8种类型的变量，这个上面已经说明了，它用一个1字节的无符号字符型字段表示，这完全是足够的。因为zval可以表示一切PHP中的数据类型, 所以它包含了一个type字段, 表示这个zval存储的是什么类型的值, 常见的可能选项是`IS_NULL, IS_LONG, IS_STRING, IS_ARRAY, IS_OBJECT`等等.   根据type字段的值不同, 我们就要用不同的方式解读value的值, 这个value是个联合体, 比如对于type是IS_STRING, 那么我们应该用`value.str`来解读`zval.value`字段, 而如果type是IS_LONG, 那么我们就要用`value.lval`来解读.

+ `refcount__gc`和`is_ref__gc`两个字段都有一个后缀__gc，gc的全称是garbage collection，就是我们通常所说的垃圾回收，搞过java的人肯定对这个概念很熟悉，显然它们是跟垃圾回收相关的。
  + 我们知道PHP是用引用计数来做基本的垃圾回收的, 所以zval中有一个refcount__gc字段, 表示这个zval的引用数目, 但这里有一个要说明的,   在5.3以前, 这个字段的名字还叫做refcount, 5.3以后, 在引入新的垃圾回收算法来对付循环引用计数的时候, 作者加入了大量的宏来操作refcount, 为了能让错误更快的显现, 所以改名为refcount__gc, 迫使大家都使用宏来操作refcount.
  + 类似的, 还有is_ref, 这个值表示了PHP中的一个类型是否是引用, 这里我们可以看到是不是引用是一个标志位.
  + 每个php变量存在一个叫"zval"的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。第一个是"is_ref"，是个bool值，用来标识这个变量是否是属于引用集合(reference set)。通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于php允许用户通过使用&来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。第二个额外字节是"refcount"，用以表示指向这个zval变量容器的变量(也称符号即symbol)个数。**所有的符号存在一个符号表中，其中每个符号都有作用域(scope)，那些主脚本(比如：通过浏览器请求的的脚本)和每个函数或者方法也都有作用域。**


>PHP是一个动态类型的语言，在PHP程序中可以给同一个变量赋予不同类型的值。对于不同的类型的值，这个变量的类型也会发生改变，对底层而言，只需要改变zval中的type字段就可以改变它的类型，这就是 **实现PHP中动态类型的基础**。


>**存在的问题:**
>+ 首先这个结构体的大小是(在64位系统)24个字节, 我们仔细看这个zval.value联合体, 其中zend_object_value是最大的长板, 它导致整个value需要16个字节, 这个应该是很容易可以优化掉的, 比如把它挪出来, 用个指针代替,因为毕竟IS_OBJECT也不是最最常用的类型.


### 传值和传引用

```
<?php
$obj = (object) ['value' => 1];
function changeObj($o) {
    $o->value = 100;
}
changeObj($obj);
var_dump($obj); // stdClass(value => 100)
```

上面的代码中的对象`$obj`在调用changeObj之后被改变了，这看起来像是传引用的。事实上并非如此的，我们从上面的表示变量的值的union中可以看到表示对象的值的类型为zend_object_value，这是一个结构体，它其中有一个long型的字段，它表示对象的ID。当要使用这个对象的时候，PHP会查找这个ID对应的真正的对象在内存中的表示，然后再对这块内存进行操作，所以上面的代码中的`$obj`和函数的参数`$o`都包含同一个对象的ID，而当`$o`在changeObj中被当做对象使用的时候，它所对应的对象跟变量`$obj`是同一个对象，所以改变这个对象中的value字段的值，就改变了保存在这个对象中的数据。resource类型的数据也有类似的行为，我们就不深究了。

对于引用很好理解，PHP中都是显示使用&操作符来表示变量是否是引用。我们现在已经看过一个传递引用的例子，这篇文章也不会详细讨论引用的应用，PHP有专门的文档来介绍怎么使用引用。不过有一点需要说明，引用跟C语言中的指针并不相同。在PHP中声明的每个变量在内存中都有一个对应的zval，如果把一个变量通过引用操作符赋值给另外一个变量，最终这两个变量都对应同一个zval，这类似于两个指针变量指向同一个地址。但是不同的是指针变量可以任意改变它的指向，而不会影响另外一个变量的指向，但是PHP中的引用则不是，采用引用赋值之后，不论这两个变量怎么改变，它们永远都对应同一个zval。

我们现在已经搞清楚了传值和传引用的特点，以及PHP就是传值的.

且慢！我们先看下面一个例子：

```
<?php
$s = memory_get_usage();
$arr = range(1,10000);
echo memory_get_usage() - $s; //1491520
$arr2 = $arr;
echo memory_get_usage() - $s; //1491640
```

这里例子首先调用range函数生成了一个包含10000个整数的数组，然后输出这个数组占用的内存的大小为1491520个字节，大约为1.42M（我的php版本是5.5.14），然后把这个数组赋值给另外一个变量，这个时候的内存消耗为1491640，约为1.42M，基本上没有变化。

按照传值的理论，`$arr2`和`$arr`是两个不同的变量，在内存中分别对应不同的zval，如果第一个`$arr`对应的zval占用1.42M的内存，那么第二个`$arr2`也应该占用这么多的内存啊，但是赋值之后总的内存空间的大小依旧为1.42M，为什么会这样呢？

在回答这个问题之前，我想先啰嗦两句，如果PHP的传值被设计成上面说的那样，PHP就不会存在了，这样的话每次赋值和函数调用都会分配一块新的内存，而且如果传递的变量占用的内存很大，要分配的内存也会相应的很大，这样内存的消耗会非常恐怖！

### 写时拷贝（copy-on-write）和引用计数（refcount）

上面问题的答案就是PHP使用了一种叫做`写时拷贝的技术`，这个技术`类似于延迟加载`，在需要用到的时候才会新建一个zval。在PHP中，有时候我们把一个变量对应的zval叫做一个拷贝（copy），写时拷贝就是指在需要向变量写入数据的时候才创建一个新的拷贝，所以有时候我们把PHP中的参数传递方式称为“传拷贝”。








### PHP7实现真正的写时拷贝

我们都知道PHP会使用写时拷贝的机制（Copy On Write）来提高程序的性能，降低内存的使用。

>例如下面这段代码，当我们将 `$va` 的值赋给 `$vb` 时，并不会创建一个新的 zval，而是将 `$va和$vb`指向同一个zval，直到`$vb`的值发生变化时才会复制出一个新的zval并将 `$vb`指向新的zval:
